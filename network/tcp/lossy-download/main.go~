package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"log"
	"net/netip"
	"os"
	"time"
)

type PCAPH struct {
	Magicnumber         int
	MajorVersion        int
	MinorVersion        int
	TimeZoneOffset      int
	TimeStampAccuracy   int
	SnapShotLength      int
	LinkLayerHeaderType LinkType
}

type Packet struct {
	Header PacketHeader
	Data   []byte
}

type PacketHeader struct {
	TimeStampUNIX      int
	TimeStampMicroNano int
	PacketLength       int
	UntruncatedLength  int
}

type TCPHeader struct {
	SourcePort           int
	DestinationPort      int
	SequenceNumber       int
	AcknowledgmentNumber int
	DataOffset           int
	Reserved             int
	CWR                  Flag
	ECE                  Flag
	URG                  Flag
	ACK                  Flag
	PSH                  Flag
	RST                  Flag
	SYN                  Flag
	FIN                  Flag
	WindowSize           [2]byte
	UrgentPointer        int
	Data                 []byte

	Options any
}

type EthernetII struct {
	SourceMac []byte
	DestMac   []byte
	Type      uint16
}

type LinkType int
type ProtocolType int
type Flag bool

const (
	LinkTypeNull     LinkType = 0
	LinkTypeEthernet LinkType = 1

	ProtocolTypeTCP ProtocolType = 6
	ProtocolTypeUDP ProtocolType = 17

	IPV4 uint16 = 0x0800
)

var (
	protocolMap = map[ProtocolType]string{
		ProtocolTypeTCP: "TCP",
		ProtocolTypeUDP: "UDP",
	}
)

func main() {
	f, err := os.Open("lossy.pcap")
	if err != nil {
		log.Fatal("Error opening file:", err)
	}

	pcapHeader, err := parsePCAPHeader(f)
	if err != nil {
		log.Fatal("Error parsing PCAP header:", err)
	}
	pcapHeader.Print()

	count := 0

	for {
		p, err := parsePacket(f)
		if err != nil {
			if err != io.EOF {
				fmt.Println(err)
			}
			break
		}
		p.Print()

		ParseEthernetII(p.Data)

		count += 1
	}

	fmt.Printf("\n\nNumber of packets %d\n", count)
}

// all fields are in the byte order written by the host
func parsePCAPHeader(f *os.File) (PCAPH, error) {
	p := make([]byte, 24)
	if _, err := f.Read(p); err != nil {
		log.Fatal("Error reading file:", err)
	}

	var pcaph struct {
		Magicnumber         uint32
		MajorVersion        uint16
		MinorVersion        uint16
		TimeZoneOffset      uint32
		TimeStampAccuracy   uint32
		SnapShotLength      uint32
		LinkLayerHeaderType uint32
	}

	r := bytes.NewReader(p)
	if err := binary.Read(r, binary.NativeEndian, &pcaph); err != nil {
		fmt.Println("binary.Read err parsing pcap header:", err)
	}

	if pcaph.Magicnumber != 0xa1b2c3d4 {
		return PCAPH{}, errors.New("magic number not correct")
	}

	if pcaph.LinkLayerHeaderType != uint32(LinkTypeEthernet) {
		return PCAPH{}, errors.New("LLH not ethernet")
	}

	pcaphHeader := PCAPH{
		Magicnumber:         int(pcaph.Magicnumber),
		MajorVersion:        int(pcaph.MajorVersion),
		MinorVersion:        int(pcaph.MinorVersion),
		TimeZoneOffset:      int(pcaph.TimeZoneOffset),
		TimeStampAccuracy:   int(pcaph.TimeStampAccuracy),
		SnapShotLength:      int(pcaph.SnapShotLength),
		LinkLayerHeaderType: LinkTypeEthernet,
	}

	return pcaphHeader, nil
}

func (p PCAPH) Print() {
	fmt.Printf("Magic Number in Little Endian % x\nVersion Number %d.%d\nSnapShot Length %d\nLLH %d\n",
		p.Magicnumber,
		p.MajorVersion,
		p.MinorVersion,
		p.SnapShotLength,
		p.LinkLayerHeaderType,
	)
}

func parsePacket(f *os.File) (Packet, EthernetII, error) {
	b := make([]byte, 16)
	if _, err := f.Read(b); err != nil {
		return Packet{}, err
	}

	var ph struct {
		TimeStampUNIX      uint32
		TimeStampMicroNano uint32
		PacketLength       uint32
		UntruncatedLength  uint32
	}

	r := bytes.NewReader(b)
	if err := binary.Read(r, binary.NativeEndian, &ph); err != nil {
		return Packet{}, errors.New(fmt.Sprintf("binary.Read err parsing packet header: %v", err))
	}

	if ph.PacketLength != ph.UntruncatedLength {
		return Packet{}, errors.New("untruncated length and packet length must be the same")
	}

	data := make([]byte, ph.PacketLength)
	if _, err := f.Read(data); err != nil {
		return Packet{}, errors.New(fmt.Sprintf("binary.Read err parsing packet data: %v", err))
	}

	return packet, nil
}

func ParseEthernetII(b []byte) (EthernetII, error) {
	e := EthernetII{
		Type:      binary.BigEndian.Uint16(b[12:14]),
		SourceMac: b[:6],
		DestMac:   b[6:12],
	}

	if int(e.Type) < 1536 {
		return e, errors.New("802.3 Ethernet frame type not supported")
	}

	if e.Type != IPV4 {
		return e, errors.New("Ethernet frame type not supported")
	}

	return e, nil
}

func (e EthernetII) Print() {
	fmt.Printf("--Ethernet II Frame--\nDestination MAC % x\nSource MAC % x\nEtherType: IPV4\n", e.DestMac, e.SourceMac, e.Type)
}

func (p Packet) Print(lltype LinkType) {
	t := time.Unix(int64(p.Header.TimeStampUNIX), int64(p.Header.TimeStampMicroNano))
	fmt.Printf("--Packet Header--\nTimeStamp: %v\nPacket Length: %d\nUntruncated Length: %d\n",
		t, p.Header.PacketLength, p.Header.UntruncatedLength)

	if lltype != LinkTypeEthernet {
		log.Fatal("Link Layer Header Type not supported")
	}

	destMac, srcMac, etherType := p.Data[:6], p.Data[6:12], p.Data[12:14]
	EtherTypeUint16 := binary.BigEndian.Uint16(etherType)

	if int(EtherTypeUint16) < 1536 {
		log.Fatal("802.3 Ethernet frame type not supported")
	}

	if EtherTypeUint16 != IPV4 {
		log.Fatal("Ethernet frame type not supported")
	}

	fmt.Printf("--Ethernet II Frame--\nDestination MAC % x\nSource MAC % x\nEtherType: IPV4\n", destMac, srcMac)

	version, ihl := p.Data[14]>>4, int(p.Data[14]&0b00001111)
	length := binary.BigEndian.Uint16(p.Data[16:18])
	id := binary.BigEndian.Uint16(p.Data[18:20])
	ttl, protocol := p.Data[22], ProtocolType(p.Data[23])

	if version != 4 {
		log.Fatal("IPV4 Version must be 4")
	}

	if protocol != ProtocolTypeTCP {
		log.Fatal("Protocol must be TCP")
	}

	sourceIP, ok := netip.AddrFromSlice(p.Data[26:30])
	if !ok {
		log.Fatal("Invalid source IP address")
	}

	destIP, ok := netip.AddrFromSlice(p.Data[30:34])
	if !ok {
		log.Fatal("Invalid destination IP address")

	}

	fmt.Printf("--IPV4 Header--\nIHL: %2d Length: %d ID: %d TTL: %d Protocol: %s SourceIP: %s DestIP: %s\n",
		ihl, length, id, ttl, protocolMap[protocol], sourceIP.String(), destIP.String())

	tcp := ParseTCP(p.Data[14+int(ihl)*4:])
	tcp.Print()
	// fmt.Println(contents)
}

func ParseTCP(b []byte) TCPHeader {
	var data struct {
		SourcePort           uint16
		DestinationPort      uint16
		SequenceNumber       uint32
		AcknowledgmentNumber uint32
	}

	r := bytes.NewReader(b[0:12])
	if err := binary.Read(r, binary.BigEndian, &data); err != nil {
		log.Fatal("binary.Read err parsing tcp headers: ", err)
	}
	dataOffset, flags := int((b[12]&0xf0)>>4)<<2, b[13]
	ack, syn, fin := flags&0b100000 > 0, flags&0b10 > 0, flags&0b1 > 0

	return TCPHeader{
		SourcePort:           int(data.SourcePort),
		DestinationPort:      int(data.DestinationPort),
		SequenceNumber:       int(data.SequenceNumber),
		AcknowledgmentNumber: int(data.AcknowledgmentNumber),
		DataOffset:           dataOffset,
		Data:                 b[dataOffset:],
		ACK:                  Flag(ack),
		SYN:                  Flag(syn),
		FIN:                  Flag(fin),
	}
}

func (tcph TCPHeader) Print() {
	fmt.Printf("--TCP Header--\nSource Port: %d Dest Port: %d\nSequence number %d Acknowledgment number %d Offset %d",
		tcph.SourcePort,
		tcph.DestinationPort,
		tcph.SequenceNumber,
		tcph.AcknowledgmentNumber,
		tcph.DataOffset,
	)

	fmt.Printf("\nFlags: ")
	if tcph.SYN {
		fmt.Print("SYN ")
	}
	if tcph.ACK {
		fmt.Print("ACK ")
	}
	if tcph.FIN {
		fmt.Print("FIN ")
	}
	fmt.Println()
	fmt.Println()
}
